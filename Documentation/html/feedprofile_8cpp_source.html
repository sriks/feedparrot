<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FeedParrot: rssmanager/feedprofile.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="feedparrot_64.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">FeedParrot
   &#160;<span id="projectnumber">0.4</span>
   </div>
   <div id="projectbrief">Qt based RSS Feed manager and parser</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('feedprofile_8cpp.html','');
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">rssmanager/feedprofile.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &lt;QHash&gt;</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &lt;QNetworkAccessManager&gt;</span>
<a name="l00003"></a>00003 <span class="preprocessor">#include &lt;QNetworkReply&gt;</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;QBuffer&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;QDebug&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;QMutex&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;QMutexLocker&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;QDir&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#ifdef Q_OS_SYMBIAN</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#include &lt;QNetworkProxyFactory&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#endif</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#include &quot;rssmanager.h&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;feedprofile.h&quot;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;rssparser.h&quot;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="keyword">const</span> QString TMP_DIR(<span class="stringliteral">&quot;tmp&quot;</span>);
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 QMutex mutex;
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 FeedProfile::FeedProfile(QUrl url,<span class="keywordtype">int</span> interval,<a class="code" href="class_r_s_s_manager.html">RSSManager</a>* mgr,QObject *parent) :
<a name="l00021"></a>00021     QObject(parent),
<a name="l00022"></a>00022     mSourceUrl(url),
<a name="l00023"></a>00023     mInterval(interval),
<a name="l00024"></a>00024     mRSSManager(mgr),
<a name="l00025"></a>00025     mNetworkManager(NULL),
<a name="l00026"></a>00026     mNetworkReply(NULL),
<a name="l00027"></a>00027     mCacheInvalidated(true),
<a name="l00028"></a>00028     mCachedCount(-1),
<a name="l00029"></a>00029     mFeedReachable(false),
<a name="l00030"></a>00030     mSmartUpdate(true)
<a name="l00031"></a>00031 {
<a name="l00032"></a>00032 <span class="preprocessor">#ifdef Q_OS_SYMBIAN</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>    QNetworkProxyFactory::setUseSystemConfiguration(<span class="keyword">true</span>);
<a name="l00034"></a>00034 <span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>    setNetworkRequestActive(<span class="keyword">false</span>);
<a name="l00036"></a>00036     mNetManCreatedCount = 0; <span class="comment">// test only</span>
<a name="l00037"></a>00037     connect(&amp;mTimer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(handleTimeOut()));
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 FeedProfile::~FeedProfile() {
<a name="l00041"></a>00041     mTimer.stop();
<a name="l00042"></a>00042     <span class="keywordflow">if</span>(isNetworkRequestActive())  {
<a name="l00043"></a>00043         mNetworkManager-&gt;deleteLater();
<a name="l00044"></a>00044         mNetworkReply-&gt;deleteLater();
<a name="l00045"></a>00045     }
<a name="l00046"></a>00046     QFile::remove(<a class="code" href="class_feed_profile.html#a4e8512cf50a4613d3f41bf040068b87d">feedFileName</a>());
<a name="l00047"></a>00047 }
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="keywordtype">bool</span> FeedProfile::isValid()<span class="keyword"> const </span>{
<a name="l00050"></a>00050     <span class="comment">// Feed with negative interval is valid</span>
<a name="l00051"></a>00051     <span class="keywordflow">return</span> mSourceUrl.isValid() &amp;&amp; mFeedReachable;
<a name="l00052"></a>00052 }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">// Fix the crash when parser is deleted.</span>
<a name="l00055"></a>00055 <span class="comment">//RSSParser* FeedProfile::parser() const {</span>
<a name="l00056"></a>00056 <span class="comment">//    if(mParser &amp;&amp; !mParser-&gt;source()) {</span>
<a name="l00057"></a>00057 <span class="comment">//        // Each profile acts on a singel xmlsource,</span>
<a name="l00058"></a>00058 <span class="comment">//        // so setting it once for ever.</span>
<a name="l00059"></a>00059 <span class="comment">//        // TODO: test this with quick update intervals.</span>
<a name="l00060"></a>00060 <span class="comment">//        QFile* src = new QFile(feedFileName(),mParser);</span>
<a name="l00061"></a>00061 <span class="comment">//        if(src-&gt;open(QIODevice::ReadOnly))</span>
<a name="l00062"></a>00062 <span class="comment">//            mParser-&gt;setSource(src);</span>
<a name="l00063"></a>00063 <span class="comment">//    }</span>
<a name="l00064"></a>00064 <span class="comment">//    // TODO: should we reset read head to beginning of the file?</span>
<a name="l00065"></a>00065 <span class="comment">//    return mParser;</span>
<a name="l00066"></a>00066 <span class="comment">//}</span>
<a name="l00067"></a>00067 
<a name="l00073"></a><a class="code" href="class_feed_profile.html#ab6898094e5bbbff57329958000fb08cf">00073</a> <span class="keywordtype">void</span> <a class="code" href="class_feed_profile.html#ab6898094e5bbbff57329958000fb08cf">FeedProfile::update</a>() {
<a name="l00074"></a>00074     <span class="comment">// Ignore if a request is already active</span>
<a name="l00075"></a>00075     <span class="keywordflow">if</span>(!isNetworkRequestActive())     {
<a name="l00076"></a>00076         handleTimeOut();
<a name="l00077"></a>00077     }
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keywordtype">void</span> FeedProfile::start() {
<a name="l00081"></a>00081     updateTimer(mInterval);
<a name="l00082"></a>00082     <span class="keywordflow">if</span>(mInterval &gt;= 0)
<a name="l00083"></a>00083         <a class="code" href="class_feed_profile.html#ab6898094e5bbbff57329958000fb08cf">update</a>();
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="keywordtype">void</span> FeedProfile::stop() {
<a name="l00087"></a>00087     updateTimer(-1);
<a name="l00088"></a>00088 }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="keywordtype">void</span> FeedProfile::updateTimer(<span class="keywordtype">int</span> msec) {
<a name="l00091"></a>00091     mTimer.stop();
<a name="l00092"></a>00092     <span class="keywordflow">if</span>(isNetworkRequestActive() &amp;&amp; mNetworkReply)
<a name="l00093"></a>00093         mNetworkReply-&gt;abort();
<a name="l00094"></a>00094     <span class="comment">// start timer if it is a valid interval</span>
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(msec&gt;=0) {
<a name="l00096"></a>00096         mTimer.setInterval(msec);
<a name="l00097"></a>00097         mTimer.start();
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099     <span class="comment">// negative timer value tells to stop updates</span>
<a name="l00100"></a>00100 }
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="class_feed_profile.html#a43feba0f4c42ac44b1fa3984398a4050">00102</a> <span class="keywordtype">bool</span> <a class="code" href="class_feed_profile.html#a43feba0f4c42ac44b1fa3984398a4050">FeedProfile::isActive</a>()<span class="keyword"> const </span>{
<a name="l00103"></a>00103     <span class="keywordflow">return</span> mTimer.isActive();
<a name="l00104"></a>00104 }
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 QString FeedProfile::latestItemCheck()<span class="keyword"> const </span>{
<a name="l00107"></a>00107     <span class="keywordflow">return</span> mLatestElementCheck;
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="keywordtype">void</span> FeedProfile::setLatestItemCheck(QString check) {
<a name="l00111"></a>00111     mLatestElementCheck = check;
<a name="l00112"></a>00112 }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="keywordtype">void</span> FeedProfile::setUserData(FeedUserData userData) {
<a name="l00115"></a>00115     mUserData = userData;
<a name="l00116"></a>00116 }
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 FeedUserData FeedProfile::userData()<span class="keyword"> const </span>{
<a name="l00119"></a>00119     <span class="keywordflow">return</span> mUserData;
<a name="l00120"></a>00120 }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keywordtype">void</span> FeedProfile::handleTimeOut() {
<a name="l00123"></a>00123     <span class="comment">// ignore</span>
<a name="l00124"></a>00124     <span class="keywordflow">if</span>(isNetworkRequestActive())
<a name="l00125"></a>00125         <span class="keywordflow">return</span>;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127     mCacheInvalidated = <span class="keyword">true</span>;
<a name="l00128"></a>00128     <span class="comment">// Fetch feed from source</span>
<a name="l00129"></a>00129     mNetworkManager = <span class="keyword">new</span> QNetworkAccessManager(<span class="keyword">this</span>); mNetManCreatedCount++;
<a name="l00130"></a>00130     connect(mNetworkManager, SIGNAL(finished(QNetworkReply*)),
<a name="l00131"></a>00131             <span class="keyword">this</span>, SLOT(replyFinished(QNetworkReply*)),Qt::UniqueConnection);
<a name="l00132"></a>00132     connect(mNetworkManager,SIGNAL(destroyed(QObject*)),
<a name="l00133"></a>00133             <span class="keyword">this</span>,SLOT(handleNetworkMgrDestroyed(QObject*)),Qt::UniqueConnection);
<a name="l00134"></a>00134     QUrl <a class="code" href="class_feed_profile.html#a5f25604a765601d87e41b97adfd709e8">url</a>(mSourceUrl.toString(),QUrl::TolerantMode);
<a name="l00135"></a>00135     mNetworkReply = mNetworkManager-&gt;get(QNetworkRequest(<span class="comment">/*mSourceUrl*/</span>url));
<a name="l00136"></a>00136     setNetworkRequestActive(<span class="keyword">true</span>);
<a name="l00137"></a>00137 }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keywordtype">void</span> FeedProfile::replyFinished(QNetworkReply *reply) {
<a name="l00140"></a>00140     QMutex m;
<a name="l00141"></a>00141     m.lock();
<a name="l00142"></a>00142         setNetworkRequestActive(<span class="keyword">false</span>);
<a name="l00143"></a>00143             <span class="comment">// No error</span>
<a name="l00144"></a>00144             <span class="keywordflow">if</span>(QNetworkReply::NoError == reply-&gt;error()) {
<a name="l00145"></a>00145                 <span class="comment">// read contents</span>
<a name="l00146"></a>00146                 QByteArray content = reply-&gt;readAll();
<a name="l00147"></a>00147                 handleContent(content);
<a name="l00148"></a>00148             } <span class="keywordflow">else</span> {
<a name="l00149"></a>00149                 <span class="comment">// handle error</span>
<a name="l00150"></a>00150                 qWarning()&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;<span class="stringliteral">&quot;:&quot;</span>&lt;&lt;reply-&gt;errorString();
<a name="l00151"></a>00151                 emit error(reply-&gt;errorString(),mSourceUrl.toString());
<a name="l00152"></a>00152             }
<a name="l00153"></a>00153         reply-&gt;deleteLater();
<a name="l00154"></a>00154         <span class="comment">// Feeds are usually gathered in periodic intervals.</span>
<a name="l00155"></a>00155         <span class="comment">// So network manager need not reside in memory till it is required.</span>
<a name="l00156"></a>00156         mNetworkManager-&gt;deleteLater();
<a name="l00157"></a>00157     m.unlock();
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="keywordtype">void</span> FeedProfile::handleContent(QByteArray content) {
<a name="l00161"></a>00161     <span class="keywordflow">if</span>(content.size()) {
<a name="l00162"></a>00162             QFile feedFile(<a class="code" href="class_feed_profile.html#a4e8512cf50a4613d3f41bf040068b87d">feedFileName</a>());
<a name="l00163"></a>00163             <span class="comment">// TODO: continue by just passing the content when feedFileName is empty</span>
<a name="l00164"></a>00164             <span class="comment">// This is required by libs which use feedparrot to get data.</span>
<a name="l00165"></a>00165             <span class="comment">// In such cases they cannot provide any application name.</span>
<a name="l00166"></a>00166 
<a name="l00167"></a>00167             <span class="keywordflow">if</span>(feedFile.exists())
<a name="l00168"></a>00168                 feedFile.remove();
<a name="l00169"></a>00169 
<a name="l00170"></a>00170             <span class="keywordflow">if</span>(feedFile.open(QIODevice::ReadWrite)) {
<a name="l00171"></a>00171                 QString tmp(content);
<a name="l00172"></a>00172                 feedFile.write(tmp.toUtf8());
<a name="l00173"></a>00173                 feedFile.close();
<a name="l00174"></a>00174             } <span class="keywordflow">else</span> {
<a name="l00175"></a>00175                 emit error(<span class="stringliteral">&quot;Cannot store the feed&quot;</span>,mSourceUrl.toString());
<a name="l00176"></a>00176                 <span class="keywordflow">return</span>;
<a name="l00177"></a>00177             }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179             <span class="keywordtype">int</span> newItemsCount=0;
<a name="l00180"></a>00180             QFile readFeedFile(<a class="code" href="class_feed_profile.html#a4e8512cf50a4613d3f41bf040068b87d">feedFileName</a>());
<a name="l00181"></a>00181             readFeedFile.open(QIODevice::ReadOnly);
<a name="l00182"></a>00182             <a class="code" href="class_r_s_s_parser.html" title="RSSParser is a special xml parser for RSS feeds. It is based on XQuery as backend. It is very light weight as it does not own the source data. Using RSSParser requires some basic knowledge of RSS elements. It suports RSS Specification http://www.rssboard.org/rss-specification.">RSSParser</a>* parser = <span class="keyword">new</span> <a class="code" href="class_r_s_s_parser.html" title="RSSParser is a special xml parser for RSS feeds. It is based on XQuery as backend. It is very light weight as it does not own the source data. Using RSSParser requires some basic knowledge of RSS elements. It suports RSS Specification http://www.rssboard.org/rss-specification.">RSSParser</a>(<span class="keyword">this</span>);
<a name="l00183"></a>00183             parser-&gt;<a class="code" href="class_r_s_s_parser.html#a61ed20107ba616368c053eb61a99ba9d" title="set RSS data source. Sets xml source to be parsed using RSSParser. The source should be opened atleas...">setSource</a>(&amp;readFeedFile);
<a name="l00184"></a>00184             QStringList checks = parser-&gt;<a class="code" href="class_r_s_s_parser.html#a101a710297658df267686d60fc8b224a" title="Convinience method to query all items for the element.">itemElements</a>(RSSParser::link);
<a name="l00185"></a>00185             <span class="keywordtype">bool</span> perr = parser-&gt;<a class="code" href="class_r_s_s_parser.html#a2565557c7f7d5b348a4c2137d6916fcb" title="returns true if the latest query resulted in error.">isError</a>();
<a name="l00186"></a>00186             <span class="keyword">delete</span> parser;
<a name="l00187"></a>00187             readFeedFile.close();
<a name="l00188"></a>00188 
<a name="l00189"></a>00189             <span class="keywordflow">if</span>(perr) {
<a name="l00190"></a>00190                 emit error(<span class="stringliteral">&quot;Unable to parse&quot;</span>,mSourceUrl.toString());
<a name="l00191"></a>00191                 <span class="keywordflow">return</span>;
<a name="l00192"></a>00192             }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194             <span class="keywordtype">int</span> totalItems = checks.count();
<a name="l00195"></a>00195             <span class="keywordflow">if</span>(totalItems) {
<a name="l00196"></a>00196                 mFeedReachable = <span class="keyword">true</span>;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198                 <span class="comment">// Assume all items are new</span>
<a name="l00199"></a>00199                 newItemsCount = totalItems;
<a name="l00200"></a>00200                 <span class="comment">// Check for updates</span>
<a name="l00201"></a>00201                 <span class="keywordflow">if</span>(!mLatestElementCheck.isEmpty() &amp;&amp; checks.contains(mLatestElementCheck))
<a name="l00202"></a>00202                     newItemsCount = checks.indexOf(mLatestElementCheck);
<a name="l00203"></a>00203                 mLatestElementCheck = checks.at(0);
<a name="l00204"></a>00204                 <span class="comment">// New updates available</span>
<a name="l00205"></a>00205                 <span class="comment">// emit this signal even if there is no active timer.</span>
<a name="l00206"></a>00206                 <span class="comment">// some clients may need update on demand.</span>
<a name="l00207"></a>00207                 <span class="keywordflow">if</span>(!mSmartUpdate)
<a name="l00208"></a>00208                     emit updateAvailable(mSourceUrl,totalItems);
<a name="l00209"></a>00209                 <span class="keywordflow">else</span> <span class="keywordflow">if</span>(mSmartUpdate)
<a name="l00210"></a>00210                     emit updateAvailable(mSourceUrl,newItemsCount);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212             } <span class="keywordflow">else</span> {
<a name="l00213"></a>00213                 emit error(tr(<span class="stringliteral">&quot;Cannot parse feed&quot;</span>),mSourceUrl.toString());
<a name="l00214"></a>00214             }
<a name="l00215"></a>00215      }
<a name="l00216"></a>00216 }
<a name="l00217"></a>00217 
<a name="l00223"></a><a class="code" href="class_feed_profile.html#a4e8512cf50a4613d3f41bf040068b87d">00223</a> QString <a class="code" href="class_feed_profile.html#a4e8512cf50a4613d3f41bf040068b87d">FeedProfile::feedFileName</a>()<span class="keyword"> const </span>{
<a name="l00224"></a>00224     QString filename;
<a name="l00225"></a>00225     filename.setNum( qHash(mSourceUrl.toString()) );
<a name="l00226"></a>00226     filename.append(<span class="stringliteral">&quot;.xml&quot;</span>);
<a name="l00227"></a>00227     <span class="keyword">static</span> QString path;
<a name="l00228"></a>00228     <span class="keywordflow">if</span>(path.isEmpty()) {
<a name="l00229"></a>00229         QString basePath = mRSSManager-&gt;<a class="code" href="class_r_s_s_manager.html#a6b15afc171af4ed4a51aa67f599edb40">storagePath</a>();
<a name="l00230"></a>00230         <span class="keywordflow">if</span>(!basePath.isEmpty()) {
<a name="l00231"></a>00231             QDir d(basePath);
<a name="l00232"></a>00232             <span class="keywordflow">if</span>(!d.cd(TMP_DIR)) {
<a name="l00233"></a>00233                 <span class="keywordflow">if</span>(!d.mkdir(TMP_DIR)) {
<a name="l00234"></a>00234                     qWarning()&lt;&lt;Q_FUNC_INFO&lt;&lt;<span class="stringliteral">&quot;Unable to create tmp folder at &quot;</span>+basePath;
<a name="l00235"></a>00235                     path.clear();
<a name="l00236"></a>00236                     <span class="keywordflow">return</span> QString();
<a name="l00237"></a>00237                 } <span class="keywordflow">else</span> {
<a name="l00238"></a>00238                     d.cd(TMP_DIR);
<a name="l00239"></a>00239                 }
<a name="l00240"></a>00240             }
<a name="l00241"></a>00241             path = d.absolutePath();
<a name="l00242"></a>00242         }
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244     <span class="keywordflow">return</span> path+<span class="stringliteral">&quot;/&quot;</span>+filename;
<a name="l00245"></a>00245 }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247 <span class="comment">//QIODevice FeedProfile::fileHandle() {</span>
<a name="l00248"></a>00248 <span class="comment">//    if(!mFile.isOpen()) {</span>
<a name="l00249"></a>00249 <span class="comment">//        mFile.setFileName(feedFileName());</span>
<a name="l00250"></a>00250 <span class="comment">//        mFile.open(QIODevice::ReadOnly);</span>
<a name="l00251"></a>00251 <span class="comment">//    }</span>
<a name="l00252"></a>00252 <span class="comment">//return mFile;</span>
<a name="l00253"></a>00253 <span class="comment">//}</span>
<a name="l00254"></a>00254 
<a name="l00258"></a>00258 <span class="comment">//int FeedProfile::count() const {</span>
<a name="l00259"></a>00259 <span class="comment">//    // TODO: do caching and return result</span>
<a name="l00260"></a>00260 <span class="comment">//    if(mCacheInvalidated || -1 == mCachedCount) {</span>
<a name="l00261"></a>00261 <span class="comment">//        mCachedCount = parser()-&gt;count();</span>
<a name="l00262"></a>00262 <span class="comment">//        mCacheInvalidated = false;</span>
<a name="l00263"></a>00263 <span class="comment">//    }</span>
<a name="l00264"></a>00264 <span class="comment">//    return mCachedCount;</span>
<a name="l00265"></a>00265 <span class="comment">//}</span>
<a name="l00266"></a>00266 
<a name="l00267"></a><a class="code" href="class_feed_profile.html#a5f25604a765601d87e41b97adfd709e8">00267</a> QUrl <a class="code" href="class_feed_profile.html#a5f25604a765601d87e41b97adfd709e8">FeedProfile::url</a>()<span class="keyword"> const </span>{
<a name="l00268"></a>00268     <span class="keywordflow">return</span> mSourceUrl;
<a name="l00269"></a>00269 }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="keywordtype">int</span> FeedProfile::interval()<span class="keyword"> const </span>{
<a name="l00272"></a>00272     <span class="keywordflow">return</span> mInterval;
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keywordtype">void</span> FeedProfile::setSmartUpdate(<span class="keywordtype">bool</span> val) {
<a name="l00276"></a>00276     mSmartUpdate = val;
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 <span class="keywordtype">bool</span> FeedProfile::hasSmartUpdate()<span class="keyword"> const </span>{
<a name="l00280"></a>00280     <span class="keywordflow">return</span> mSmartUpdate;
<a name="l00281"></a>00281 }
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="comment">// test slot</span>
<a name="l00284"></a>00284 <span class="keywordtype">void</span> FeedProfile::handleNetworkMgrDestroyed(QObject *obj) {
<a name="l00285"></a>00285     QMutex m;
<a name="l00286"></a>00286     m.lock();
<a name="l00287"></a>00287     mNetManCreatedCount--;
<a name="l00288"></a>00288     <span class="keywordflow">if</span>(obj)
<a name="l00289"></a>00289         obj-&gt;objectName();
<a name="l00290"></a>00290     m.unlock();
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293 <span class="keywordtype">void</span> FeedProfile::setNetworkRequestActive(<span class="keywordtype">bool</span> value) {
<a name="l00294"></a>00294     QMutex m;
<a name="l00295"></a>00295     m.lock();
<a name="l00296"></a>00296     mNetworkRequestActive = value;
<a name="l00297"></a>00297     m.unlock();
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="keywordtype">bool</span> FeedProfile::isNetworkRequestActive() {
<a name="l00301"></a>00301     <span class="keywordflow">return</span> mNetworkRequestActive;
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="comment">// eof</span>
</pre></div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>feedprofile.cpp</b>      </li>

    <li class="footer">Generated on Mon May 14 2012 13:34:24 for FeedParrot by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0 </li>
   </ul>
 </div>


</body>
</html>
